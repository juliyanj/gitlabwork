2-nd
brbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbrbr
Эта команда создаёт в текущей директории новую поддиректорию с именем .git, содержащую все необходимые файлы репозитория — основу Git-репозитория.
$ git init

Если вы хотите добавить под версионный контроль существующие файлы
$ git add *.c
$ git add LICENSE
$ git commit -m 'initial project version'

Клонирование репозитория осуществляется командой git clone [url]. 
Например, если вы хотите клонировать библиотеку libgit2
$ git clone https://github.com/libgit2/libgit2

Для того, чтобы клонировать репозиторий в директорию с именем, отличающимся от “libgit2”, 
необходимо указать желаемое имя, как параметр командной строки:
$ git clone https://github.com/libgit2/libgit2 mylibgit

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда git status. 
Если вы выполните эту команду сразу после клонирования, вы увидите что-то вроде этого:
$ git status
On branch master
nothing to commit, working directory clean

Предположим, вы добавили в свой проект новый файл, простой файл README. 
Eсли этого файла раньше не было, и вы выполните git status, вы увидите свой неотслеживаемый файл вот так:
$ echo 'My Project' > README
$ git status
On branch master
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)

Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда git add. 
Чтобы начать отслеживание файла README, вы можете выполнить следующее:
$ git add README
Если вы снова выполните команду status, то увидите, что файл README теперь отслеживаемый и индексированный:

$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Индексация изменённых файлов
Давайте модифицируем файл, уже находящийся под версионным контролем. 
Если вы измените отслеживаемый файл ``CONTRIBUTING.md`` 
и после этого снова выполните команду git status, то результат будет примерно следующим:
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

Выполним git add, чтобы проиндексировать ``CONTRIBUTING.md``, а затем снова выполним git status:
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
Теперь оба файла проиндексированы и войдут в следующий коммит. 

В этот момент вы, предположим, вспомнили одно небольшое изменение, которое вы хотите сделать в ``CONTRIBUTING.md`` до фиксации. 
Вы открываете файл, вносите и сохраняете необходимые изменения и вроде бы готовы к коммиту. Но давайте-ка ещё раз выполним git status:
файл индексир. и не индексир. одновременно

$ vim CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md

Если вы изменили файл после выполнения git add, в
ам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла:
$ git add CONTRIBUTING.md
$ git status
On branch master
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
Сокращенный вывод статуса git status -s или git status --short:

$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt

Новые, неотслеживаемые файлы помечены ?? слева от них, 
файлы добавленные в отслеживаемые помечены A, 
отредактированные файлы помечены M и так далее.

Игнорирование файлов
$ cat .gitignore
*.[oa]
*~

Просмотр индексированных и неиндексированных изменений
Чтобы увидеть, что же вы изменили, но пока не проиндексировали, наберите 
git diff
Если вы хотите посмотреть, что вы проиндексировали и что войдёт в следующий коммит
git diff --staged
git diff --cached

Фиксация изменений
$ git commit
Для ещё более подробного напоминания, что же именно вы поменяли, можете передать аргумент -v в команду git commit. 
Это приведёт к тому, что в комментарий будет также помещена дельта/diff изменений, вы сможете точно увидеть все изменения

Есть и другой способ — вы можете набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его после параметра -m, как в следующем примере:

$ git commit -m "Story 182: Fix benchmarks for speed"
[master 463dc4f] Story 182: Fix benchmarks for speed
 2 files changed, 2 insertions(+)
 create mode 100644 README

Без индексации - добавить -а
$ git commit -a -m 'added new benchmarks'